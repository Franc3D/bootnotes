Terminologies to know when coding

***OOP-Object oriented programming***

DRY - Don't repeat yourself
    Make sure that if a formula is to be repeated you must put it in a function

Variables


Function
    Allows code to be useful multiple times 

    Def name_of_function(propertie, propertie2,...)
        code of function here
    Called using name_of_function(argument(s))

    Examples of functions
        len(list) -足足> Give the length of a list
        print(text) -足> Print to stdout (standard output)


Class and Objects
    A Class is a way to store data for an object
    class Soldier:
        # A class usually contains properties
        health = 5
        armor = 3
        damage = 2

    An object is an instance of a class
        for instance, the following objects :
        health = 50 is an INSTANCE of an integer
        aragorn = Soldier() is an INSTANCE of a Soldier class type

    Get the properties of an object this way :
        current_health = aragorn.health
        # current_health = 5

    Constructors
    makes initialising an object safer and more configurable
        class Soldier:
            def __init__(self, name, armor, num_weapons):
                self.name = name
                self.armor = armor
                self.num_weapons = num_weapons
        
        # Upon creating a Soldier object you will be able to define all the properties
        soldier_one = Soldier("Steve", 3, 2)
            # All the properties have been filled right at the start

    
Methods
    A method is just a function that's tied directly to the class and has access to its properties
    Here us an example of a soldier taking damage

        class Soldier:
            health = 5

            # This is a method that reduces the health of the soldier
            def take_damage(self, damage):        SELF refers to the object the method is being called upon
                self.health -= damage

        soldier_one = Soldier()
        soldier_one.take_damage(2)
        print(soldier_one.health)
        # prints "3"

    self has to be the first parameter in your methods otherwise an error will occur

    Your method can return values if necessary
        class Soldier:
            armor = 2
            num_weapons = 2

            def get_speed(self):
                speed = 10
                speed -= self.armor
                speed -= self.num_weapons
                return speed                   #Returns the calculated speed as a value

        soldier_one = Soldier()
        print(soldier_one.get_speed())
        # prints "6"

Class variables VS Instanced variables

	Class variables
		They apply to ALL instances of a class making them rarely useful
		# A Soldier class may have a class variable that is a description of the unit
		Soldier.description = ("Does shooty-shoot-shoot")
		# soldier_one & soldier_two now have access to the description

	Instanced variables
		The variables used is unique to each instances of a class, making each object unique
		# ex. Keeping count of the HP value of a unit

Public or private properties
    By default, properties are all public
    To turn properties private simply put 2 __ before the property name during __init__
    class Wall:
        def __init__(self, armor, magic_resistance):
            self.__armor = armor
            self.__magic_resistance = magic_resistance
    
    front_wall = Wall(10, 20)

    # This results in an error
    print(front_wall.__armor)

    Useful of you don't want the properties themselves to be used but would rather use methods form the class.
    If you are a bakery, don't show your flour or eggs, rather show your bread and pastries made using those ingredients


ENCAPSULATION AND ABSTRACTION
    make the use of functions intuitive, make sure it's obvious what happens inside with the name alone
    if a function created by a rocket scientist is called caculate_rocket_acceleration(mass,thrust,wind_resistance)
    There is no need for you to become a rocket scientist yourself, just give it the values and get the acceleration 

    1) Abstraction -    is about creating a simple interface for complex behavior. It focuses on what's exposed (public).
                            They need to be made well right away because changing functions later can be disastrous
    2) Encapsulation -  is about hiding internal state. It focuses on tucking away the implementation details (private).
                            Hide values you don't want people to use using __value.

    Generally you will want to make the interface as easy to use as possible using these phylosophies


INHERITANCE
    Inheritance allows a "child" class, to inherit properties and methods from a "parent" class. It's a way to share code between classes
    if you have a class Human
    and you make a class Archer(Human)
    The archer class now has all the properties and methods of Human on top of being able to add its own
    
    super[].__init__(data, data2, etc.)    <-- Parent __init__
    self.__num_arrows = num_arrows         <-- Child __init__
    to set the parent properties.

    It saves a lot of time over redoing all the work you already did once and if 

    Tiger 足> feline > animal > LivingThings
    Inheritance can go pretty deep !

POLYMORPHISM
    If all classes have the same .move() method they can all be called in quick succession using something like :
        for creature in [Creature(), Dragon(), Kraken()]:
            creature.move()   

    Function signature
    If the name, input and output are all the same across methods in multiple class it is said that they have the same function signature.
    It means that 2 different class could call the methods with identical signatures the same way.
    class Human:
        def hit_by_fire(self):
            self.health -= 5
            return self.health

    class Archer:
        def hit_by_fire(self):    # def hit_by_fire(self, EXTRA_PARAMETER): # would not have same signature as Human
            self.health -= 10
            return self.health

    for unit in [archer_unit, human_unit]
        print(unit.hit_by_fire())
        # Would print for both class types without issue

OPERATOR OVERLOADING (+ - * / in classes)
    Adding your own operators (+) to a class using __add__ 
    normally you can do 2 + 4 or "string " + "add" but you cannot add 2 class values together unless...

    Operation 	Operator 	Method
    Addition 	        + 	__add__
    Subtraction 	    - 	__sub__
    Multiplication 	    * 	__mul__
    Power 	            ** 	__pow__
    Division 	        / 	__truediv__
    Floor Division 	    // 	__floordiv__
    Remainder (modulo) 	% 	__mod__
    Bitwise Left Shift 	<< 	__lshift__
    Bitwise Right Shift >> 	__rshift__
    Bitwise AND 	    & 	__and__
    Bitwise OR 	        | 	__or__
    Bitwise XOR 	    ^ 	__xor__
    Bitwise NOT 	    ~ 	__invert__

    the __str__ built in method can be called with the print function
        print(class_object)
        # <Point object at 0xa0acf8>

    You can modify the print command by creating a method __str__ (__repr__ also works but is reserved for debugging using eval())
        def __str__(self):
            return f"I am {self.name}, the {self.color} dragon"
            # I am Smaugh the red dragon

Exceptions
    They are a clean way to halt the code once something unusual is encountered
    (In a class) 
    def is_alive(self)
        if self.health <= 0:
                raise Exception(f"{self.name} is dead")
            
    # This will halt the code and return a stderr showing the message
    # Display the message using a try : Except
    try:
        player.is_alive()
    except Exception as e
        print("Exception caught",e)

    # Exceptions have many built-in class names each looking for different things
        Exception
        NameError
        ValueError
        IndexError
        ZeroDivisionError




The basic terms in shell
    stdout -> Standard output (print() usually)
    stdin -> Reading an input (input() lets the user write)
    stderr -> standard error (for when things go wrong)
